---
title: "操作系统-lec1"
date: 2021-12-18T11:59:38+08:00
draft: false
categories: os
---

### 操作系统

大家好，欢迎来到CIT-操作系统这门课程。理解操作系统的设计和实现。

设计是指整体的结构，实现是指具体的代码长什么样。对于这两者，我都会花费大量时间讲解。为了深入了解具体的工作原理，你可以通过一个小的叫做XV6的操作系统，获得实际动手经验。通过研究现有的操作系统，并结合课程配套的实验，你可以获得扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件

### 操作系统的任务

1. 第一个就是抽象硬件。通常来说，你会买一个计算机，里面包含了CPU，内存，但是这是一种非常低层级的资源。幸好我们有一些应用程序实现了高层级的接口和抽象，例如进程，文件系统。这些高层级的接口和抽象 **（Abstraction）** 方便了应用的开发，也提供了更好的移植性。
2. 操作系统的另一个重要的任务是：在多个应用程序之间共用硬件资源。你可以在一个操作系统同时运行文本编辑器，程序编译器，多个数据库等等。操作系统能非常神奇的在不相互干扰的前提下，同时运行这些程序。这里通常被称为 **(multiplex)**
3. 因为在操作系统中可能同时运行很多程序，即使程序出现了故障，多个程序之间互不干扰就变得非常重要。所以这里需要隔离性 **(Isolation)**，不同的活动之间不能相互干扰。
4. 但是另一方便，不同的活动之间有时又想要相互影响，比如说数据交互，协同完成任务等。举个例子，我通过文本编辑器创建了一个文件，并且我希望我的编译器能读取文件，我绝对想要数据能共享。所以，我们希望能在需要的时候实现共享 **（Sharing）**

5. 但是在很多场景下，用户并不想要共享，比如你登录到了一个公共的计算机，例如Athena，你不会想要其他人来读取你的文件。所以在共享的同时，我们也希望在没有必要的时候不共享。这里我们称为 **(Security)** 或者Permission System或者是Access Control System。

6. 另一个人们认为操作系统应该具有的价值是：如果你在硬件上花费了大量的金钱，你会期望你的应用程序拥有硬件应该提供的完整性能，但是很多时候你只负责应用程序编程，你会期望操作系统也必须保证自身提供的服务不会阻止应用程序获得高性能。所以操作系统需要至少不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能 **（Performance）**
7. 最后，对于大部分操作系统，必须要支持大量不同类型的应用程序，或许这是一个笔记本，正在运行文本编辑器，正在运行游戏，或许你的操作系统需要支持数据库服务器和云计算。通常来说，设计并构造一个操作系统代价是非常大的，所以人们总是希望在相同的操作系统上，例如Linux，运行大量的任务。我认为大部分人都已经跑过Linux，并使用了我刚刚描述的所有的场景。所以，同一个操作系统需要能够支持大量不同的用户场景 **(range of uses)**

### 操作系统结构

过去几十年，人们将一些分层的设计思想加入到操作系统中，并运行的很好。我将会为你列出操作系统经典的组织结构，这个组织结构同时也是这门课程的主要内容，这里的组织结构对于操作系统来说还是挺常见的

当进程需要调用内核服务时，它会调用系统调用，这是操作系统接口中的调用之一。 系统调用进入内核； 内核执行服务并返回。 因此，一个进程在用户空间和内核空间之间交替执行

我们同时也对应用程序是如何与Kernel交互，它们之间的接口长什么样感兴趣。这里通常成为Kernel的API，它决定了应用程序如何访问Kernel。通常来说，这里是通过所谓的系统调用（System Call）来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。在这门课程的后面，我会详细介绍系统调用。现在，我只会介绍一些系统调用在应用程序中是长什么样的

第一个例子是，如果应用程序需要打开一个文件，它会调用名为open的系统调用，并且把文件名作为参数传给open。假设现在要打开一个名为“out”的文件，那么会将文件名“out”作为参数传入。同时我们还希望写入数据，那么还会有一个额外的参数，在这里这个参数的值是1，表明我想要写文件。

这里看起来像是个函数调用，但是open是一个系统调用，它会跳到Kernel，Kernel可以获取到open的参数，执行一些实现了open的Kernel代码，或许会与磁盘有一些交互，最后返回一个文件描述符对象。上图中的fd全称就是file descriptor。之后，应用程序可以使用这个文件描述符作为handle，来表示相应打开的文件。

如果你想要向文件写入数据，相应的系统调用是write。你需要向write传递一个由open返回的文件描述符作为参数。你还需要向write传递一个指向要写入数据的指针（数据通常是char型序列），在C语言中，可以简单传递一个双引号表示的字符串（下图中的\n表示是换行）。第三个参数是你想要写入字符的数量。

这些系统调用看起来就跟普通的函数调用一样。系统调用不同的地方是，它最终会跳到系统内核中

![](https://raw.githubusercontent.com/cit965/blog-picture/master/Screen%20Shot%202021-12-18%20at%2012.07.14%20PM.png)

```sh
fd = open("out",1)
write(fd,"hello\n",6)
```

### 授课内容

授课内容是这门课程的一大部分，我会讲解操作系统的基本概念。有几节课会专注于学习**XV6**中的代码，XV6是我们的一个小的用于教学的操作系统，我们会介绍它是如何工作，查看它的代码，并在课程中演示代码的运行。在每一节课程之前都会有作业，作业会要求你们阅读介绍XV6的书籍，书籍的内容是XV6如何运行以及设计思想。所以你应该在课程之前完成相应的阅读，这样你才能理解课程的讨论内容。有几节课会专注于帮助你完成实验内容，例如解释C语言是如何工作的，例如介绍RISC-V是如何工作的，这是我们将要使用的一个微处理器。这些内容对于你们完成实验是有帮助的。在课程的结束部分，我们会花几节课时间来阅读一些操作系统相关的论文，包括一些研究论文和一些经典论文。我们会要求你在课程之前阅读这些论文，我们也会在课堂上讨论这些论文。几乎对于所有的课，我们会要求你对于阅读材料提出一些问题，我们会读取这些问题，以帮助我们决定课程上讲解什么内容，并且我们也会尽可能的回答这些问题

### fork

fork会创建一个新的进程，下面是使用fork的一个简单用例

```c
// fork.c create a new process
#include "kernel/types.h"
#include "use/user.h"

int main()
{
  	int pid;
  	pid = fork(); 												//line 12
  	printf("fork() returned %d\n",pid);
  	if (pid == 0){												//line 16
   	 	printf("child\n");
  	}else{
   		printf("parent\n");
  	}
  	 exit(0)
}
```



在第12行，我们调用了fork。fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后，我们就有了两个拥有完全一样内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork系统调用会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程

在第16行，你可以看到代码检查pid。如果pid等于0，那么这必然是子进程。在我们的例子中，调用进程通常称为父进程，父进程看到的pid必然大于0。所以父进程会打印“parent”，子进程会打印“child”。之后两个进程都会退出。接下来我运行这个程序

输出看起来像是垃圾数据。这里实际发生的是，fork系统调用之后，两个进程都在同时运行，QEMU实际上是在模拟多核处理器，所以这两个进程实际上就是同时在运行。所以当这两个进程在输出的时候，它们会同时一个字节一个字节的输出，两个进程的输出交织在一起，所以你可以看到两个f，两个o等等。在第一行最后，你可以看到0，这是子进程的输出。我猜父进程返回了19，作为子进程的进程ID。通常来说，这意味着这是操作系统启动之后的第19个进程。之后一个进程输出了child，一个进程输出了parent，这两个输出交织在一起。虽然这只是对于fork的一个简单应用，但是我们可以清晰的从输出看到这里创建了两个运行的进程，其中一个进程打印了child，另一个打印了parent。所以，fork（在子父进程中）返回不同的值是比较重要的

### 重定向

文件描述符和 fork 交互使 I/O 重定向易于实现。 Fork 将父进程的文件描述符表连同其内存一起复制，以便子进程从与父进程完全相同的打开文件开始。 系统调用 exec 替换调用进程的内存但保留其文件表。 这种行为允许 shell 通过派生、重新打开子进程中选定的文件描述符，然后调用 exec 来运行新程序来实现 I/O 重定向。 这是 shell 为命令 cat < input.txt 运行的代码的简化版本：

```c
char *argv[2]; 
argv[0] = "cat"; 
argv[1] = 0;
if(fork() == 0) {
	close(0);
	open("input.txt", O_RDONLY);
	exec("cat", argv); 
}

```

### lab实验

实验内容以及环境搭建不清楚的话欢迎加入CIT组织

你可以通过邮件联系我们 chaoyueshijian@gmail.com